<?php

/**
 * @file
 * Install, update and uninstall functions for the markdown module.
 */

use Drupal\Component\Render\FormattableMarkup;
use Drupal\Core\Link;
use Drupal\Core\Render\Markup;
use Drupal\markdown\Annotation\InstallableLibrary;
use Drupal\markdown\Plugin\Markdown\ParserInterface;
use Drupal\markdown\PluginManager\ParserManager;

/**
 * Implements hook_requirements().
 *
 * {@inheritdoc}
 *
 * Note: this is currently being ignored in Drush >=9 <=9.7.2.
 *
 * @see https://github.com/drush-ops/drush/pull/4337
 * @noinspection PhpInappropriateInheritDocUsageInspection
 * @noinspection PhpUnused
 */
function markdown_requirements($phase) {
  // Indicate that any subsequent code invoked is because of this hook.
  // This assists in special use-casing to avoid errors when the module isn't
  // yet installed.
  global $_markdown_requirements;
  $_markdown_requirements = $phase;

  $requirements = [];

  /** @var \Drupal\Core\Render\RendererInterface $renderer */
  $renderer = \Drupal::service('renderer');

  // Load the Markdown Parser Plugin Manager service, if it exists.
  if (\Drupal::hasService('plugin.manager.markdown.parser')) {
    $parserManager = \Drupal::service('plugin.manager.markdown.parser');
  }
  // Otherwise, in the event that markdown isn't yet installed, register this
  // module's path in the autoloader and container namespaces. This will allow
  // the service to be manually constructed to discover installed parsers.
  else {
    $src = __DIR__ . '/src';
    /** @var \Composer\Autoload\ClassLoader $classLoader */
    $classLoader = \Drupal::service('class_loader');
    $classLoader->addPsr4('Drupal\\markdown\\', [$src]);

    /** @var \ArrayObject $containerNamespaces */
    $containerNamespaces = \Drupal::service('container.namespaces');
    if (!$containerNamespaces->offsetExists('Drupal\\markdown')) {
      $containerNamespaces->offsetSet('Drupal\\markdown', str_replace(\Drupal::root() . '/', '', $src));
    }

    $parserManager = ParserManager::create();
  }

  // Reset parser plugin cache.
  $parserManager->clearCachedDefinitions();

  // Retrieve all available parsers.
  $parsers = $parserManager->all();

  // Retrieve all installed parsers.
  $installed = $parserManager->installed();

  // Install.
  if ($phase === 'install') {
    if (!$installed) {
      $cli = php_sapi_name() === 'cli';
      $items = array_map(function (ParserInterface $parser)  use ($cli) {
        $definition = $parser->getPluginDefinition();
        if ($definition->requirementViolations) {
          $reason = implode(', ', $definition->requirementViolations);
        }
        else {
          $reason = t('Not Installed');
        }
        $url = $parser->getUrl();
        $urlString = $url ? $url->toString() : NULL;
        $urlLink = !$cli && $url ? Link::fromTextAndUrl($url->toString(), $url)->toString() : $urlString;
        return new FormattableMarkup($urlLink ? '@label: @reason (@url)' : '@label: @reason', [
          '@label' => $parser->getLabel(),
          '@reason' => $reason,
          '@url' => $urlLink,
        ]);
      }, $parsers);
      if ($cli) {
        $items = new FormattableMarkup("\n  - @items", [
          '@items' => implode("\n  - ", $items),
        ]);
      }
      else {
        $list = [
          '#theme' => 'item_list__markdown_parsers',
          '#items' => $items,
        ];
        $items = $renderer->renderPlain($list);
      }
      $requirements['markdown'] = [
        'description' => t("Markdown cannot be installed because there are no parsers currently installed. Please install at least one parser via Composer to enable this module:\n@parsers", [
          '@parsers' => $items,
        ]),
        'severity' => REQUIREMENT_ERROR,
      ];
    }
  }
  // Runtime.
  elseif ($phase === 'runtime') {
    $build = [
      '#theme' => 'table__markdown_parser_requirements',
      '#header' => [
        t('Supported Parsers'),
        t('Status'),
      ],
      '#rows' => [],
    ];
    $build['#attached']['library'][] = 'markdown/admin';

    $severity = REQUIREMENT_OK;
    foreach ($parsers as $name => $parser) {
      $library = $parser->getInstalledLibrary();
      $librarySeverity = REQUIREMENT_OK;

      $class = '';
      if ($library) {
        $class = 'color-success';
        if ($library->deprecated) {
          $class = 'color-error';
          $librarySeverity = REQUIREMENT_ERROR;
        }
        elseif ($library->getNewerVersions()) {
          $class = $parser->isPreferredLibraryInstalled() ? 'color-info' : 'color-warning';
          $librarySeverity = REQUIREMENT_WARNING;
        }
      }

      $row = [];
      if ($url = $parser->getUrl()) {
        $row[] = Link::fromTextAndUrl($parser->getLabel(FALSE), $url);
      }
      else {
        $row[] = $parser->getLabel(FALSE);
      }
      $row[] = [
        'data' => $parser->buildLibrary($library),
      ];
      $build['#rows'][] = [
        'class' => $class,
        'data' => $row,
      ];

      if ($librarySeverity > $severity) {
        $severity = $librarySeverity;
      }
    }

    $requirements['markdown'] = [
      'title' => Markup::create('Markdown<a id="markdown"></a>'),
      'severity' => $severity,
      'value' => ($count = count($installed)) === 1 ? t('1 parser installed') : t('@count parsers installed', [
        '@count' => $count,
      ]),
    ];

    if (!$installed) {
      $requirements['markdown']['severity'] = REQUIREMENT_ERROR;
      $requirements['markdown']['value'] .= '. ' . t('You must install at least one parser via Composer for the Markdown module to function properly.');
    }

    $requirements['markdown']['description'] = $renderer->render($build);
  }

  return $requirements;
}
